"""
Integration Module cho Region Division v√† PLC Communication
Chia pallets th√†nh regions v√† g·ª≠i t·ªça ƒë·ªô Px, Py c·ªßa c√°c regions v√†o PLC th√¥ng qua DB26.

Ch·ª©c nƒÉng:
1. Ph√°t hi·ªán pallets b·∫±ng YOLO
2. Chia pallets th√†nh 3 regions s·ª≠ d·ª•ng Module Division
3. Truy·ªÅn t·ªça ƒë·ªô robot (Px, Py) c·ªßa c√°c regions v√†o PLC DB26
4. Monitoring v√† logging
"""
import cv2
import time
import os
import threading
import numpy as np
from typing import List, Dict, Any, Optional, Tuple
from plc_communication import DB26Communication
from detection import (YOLOTensorRT, ModuleDivision)
from detection.utils.robot_coordinate_transform import RobotCoordinateTransform
from detection.utils.region_manager import RegionManager

class RegionDivisionPLCIntegration:
    """
    Class ch√≠nh t√≠ch h·ª£p Region Division v·ªõi PLC Communication
    """
    
    def __init__(self, 
                 plc_ip: str = "192.168.0.1", 
                 plc_rack: int = 0, 
                 plc_slot: int = 1,
                 debug: bool = True):
        """
        Args:
            plc_ip: IP address c·ªßa PLC
            plc_rack: Rack number c·ªßa PLC
            plc_slot: Slot number c·ªßa PLC
            debug: B·∫≠t ch·∫ø ƒë·ªô debug
        """
        self.debug = debug
        
        # Kh·ªüi t·∫°o c√°c component
        self.module_divider = ModuleDivision(debug=debug)
        self.robot_transformer = RobotCoordinateTransform()
        self.region_manager = RegionManager(auto_load_offsets=True)
        self.plc_comm = DB26Communication(plc_ip, plc_rack, plc_slot)
        
        # DB26 Memory Layout cho Region Coordinates (Theo y√™u c·∫ßu m·ªõi):
        # loads: DB26.0 (Px), DB26.4 (Py) 
        # pallets1: DB26.12 (Px), DB26.16 (Py)
        # pallets2: DB26.24 (Px), DB26.28 (Py)
        # bag_number: DB26.40 (INT - 2 bytes)
        self.db26_offsets = {
            'loads': {'px': 0, 'py': 4},
            'pallets1': {'px': 12, 'py': 16}, 
            'pallets2': {'px': 24, 'py': 28},
            'bag_number': {'offset': 40}  # Offset 40 for bag number (INT)
        }
        
        # Tracking data
        self.last_regions_data = []
        self.plc_connected = False
        
        # ‚≠ê BAG PALLET TRACKING SYSTEM ‚≠ê
        # Theo d√µi ri√™ng bi·ªát t·ª´ng region ƒë·ªÉ d·ªÖ tr√≠ch xu·∫•t
        self.bag_pallet_1 = 1  # Default tracking cho pallets1
        self.bag_pallet_2 = 1  # Default tracking cho pallets2  
        self.current_region_data = {
            'loads': None,      # L∆∞u data region loads
            'pallets1': None,   # L∆∞u data region pallets1
            'pallets2': None    # L∆∞u data region pallets2
        }
        
        # ‚≠ê BAG SEQUENCE SETTINGS ‚≠ê
        self.current_bag_number = 1  # Bag hi·ªán t·∫°i ƒëang ƒë·∫∑t (1, 2, ho·∫∑c 3)
        self.bag_to_region_mapping = {
            1: 1,  # bao 1 ‚Üí region_id 1 (R1) 
            2: 3,  # bao 2 ‚Üí region_id 3 (R3)
            3: 2   # bao 3 ‚Üí region_id 2 (R2, center, cu·ªëi c√πng)
        }
        
        if self.debug:
            print(f"[RegionPLC] Kh·ªüi t·∫°o v·ªõi PLC: {plc_ip}:{plc_rack}:{plc_slot}")
            print(f"[RegionPLC] DB26 Memory Layout (Updated):")
            for region_name, offsets in self.db26_offsets.items():
                if region_name == 'bag_number':
                    print(f"  {region_name}: DB26.{offsets['offset']} (INT)")
                else:
                    print(f"  {region_name}: Px=DB26.{offsets['px']}, Py=DB26.{offsets['py']}")
    
    def connect_plc(self) -> bool:
        """
        K·∫øt n·ªëi ƒë·∫øn PLC
        
        Returns:
            bool: True n·∫øu k·∫øt n·ªëi th√†nh c√¥ng
        """
        if self.debug:
            print(f"[RegionPLC] ƒêang k·∫øt n·ªëi PLC...")
        
        self.plc_connected = self.plc_comm.connect()
        
        if self.plc_connected:
            if self.debug:
                print(f"[RegionPLC] ‚úÖ K·∫øt n·ªëi PLC th√†nh c√¥ng!")
        else:
            if self.debug:
                print(f"[RegionPLC] ‚ùå K·∫øt n·ªëi PLC th·∫•t b·∫°i!")
        
        return self.plc_connected
    
    def disconnect_plc(self):
        """Ng·∫Øt k·∫øt n·ªëi PLC"""
        if self.plc_connected:
            self.plc_comm.disconnect()
            self.plc_connected = False
            if self.debug:
                print(f"[RegionPLC] PLC ƒë√£ ng·∫Øt k·∫øt n·ªëi")
    
    def process_detection_and_divide_regions(self, detections: Dict[str, Any], layer: int = 1) -> List[Dict]:
        """
        X·ª≠ l√Ω detection v√† chia pallets th√†nh regions
        
        Args:
            detections: K·∫øt qu·∫£ detection t·ª´ YOLO
            layer: Layer ƒë·ªÉ chia (1 ho·∫∑c 2)
            
        Returns:
            List[Dict]: Danh s√°ch regions v·ªõi robot coordinates
        """
        if self.debug:
            print(f"\n[RegionPLC] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω detection v√† chia regions (Layer {layer})")
        
        # ‚≠ê ENHANCED DEBUG: Check input detections ‚≠ê
        if self.debug:
            print(f"[RegionPLC] Input: {len(detections.get('classes', []))} detections, {len(detections.get('corners', []))} corners")
        
        # Ch·ªâ x·ª≠ l√Ω pallets (class 2.0)
        pallet_classes = [2.0]
        
        # Chia pallets th√†nh regions s·ª≠ d·ª•ng Module Division
        if self.debug:
            print(f"[RegionPLC] Calling ModuleDivision...")
        divided_result = self.module_divider.process_pallet_detections(
            detections, 
            layer=layer, 
            target_classes=pallet_classes
        )
        
        # ‚≠ê ENHANCED DEBUG: Check divided_result ‚≠ê
        if self.debug:
            success = divided_result.get('processing_info', {}).get('success', False)
            total_regions = divided_result.get('total_regions', 0)
            print(f"[RegionPLC] ModuleDivision result: success={success}, total_regions={total_regions}")
        
        # Chu·∫©n b·ªã d·ªØ li·ªáu regions
        if self.debug:
            print(f"[RegionPLC] Calling prepare_for_depth_estimation...")
        regions_data = self.module_divider.prepare_for_depth_estimation(divided_result)
        
        # ‚≠ê ENHANCED DEBUG: Check regions_data ‚≠ê
        if self.debug:
            print(f"[RegionPLC] Final regions_data: {len(regions_data)} regions")
            for i, region_data in enumerate(regions_data):
                region_info = region_data.get('region_info', {})
                pallet_id = region_info.get('pallet_id', 'MISSING')
                region_id = region_info.get('region_id', 'MISSING')
                center = region_data.get('center', [0, 0])
                print(f"  Final Region {i}: P{pallet_id}R{region_id} center=({center[0]:.1f}, {center[1]:.1f})")
        
        if self.debug:
            print(f"[RegionPLC] ƒê√£ chia ƒë∆∞·ª£c {len(regions_data)} regions")
        
        # ‚≠ê RESET CURRENT REGION DATA ‚≠ê
        self.current_region_data = {
            'loads': None,
            'pallets1': None,
            'pallets2': None
        }
        
        # Chuy·ªÉn ƒë·ªïi pixel coordinates sang robot coordinates cho t·ª´ng region
        regions_with_robot_coords = []
        
        for i, region_data in enumerate(regions_data):
            center_pixel = region_data['center']
            region_info = region_data['region_info']
            
            # Chuy·ªÉn ƒë·ªïi pixel center sang robot coordinates  
            robot_x, robot_y = self.robot_transformer.camera_to_robot(
                center_pixel[0], center_pixel[1]
            )
            
            # ‚≠ê √ÅP D·ª§NG OFFSET T·ª™ REGIONMANAGER ‚≠ê
            # X√°c ƒë·ªãnh region name ƒë·ªÉ √°p d·ª•ng offset ph√π h·ª£p
            region_name = self._determine_region_name(center_pixel, region_info)
            
            if region_name:
                # √Åp d·ª•ng offset t·ª´ RegionManager
                robot_coords_with_offset = self.region_manager.apply_region_offset(
                    {'x': robot_x, 'y': robot_y}, 
                    region_name
                )
                robot_x = robot_coords_with_offset['x']
                robot_y = robot_coords_with_offset['y']
                
                if self.debug:
                    offset = self.region_manager.regions[region_name]['offset']
                    print(f"    √Åp d·ª•ng offset {region_name}: X+{offset['x']}, Y+{offset['y']}")
            
            # T·∫°o region data v·ªõi robot coordinates
            region_with_coords = {
                'region_id': region_info['region_id'],
                'pallet_id': region_info['pallet_id'], 
                'global_region_id': region_info.get('global_region_id', i+1),
                'layer': layer,
                'pixel_center': center_pixel,
                'robot_coordinates': {
                    'px': round(robot_x, 2),
                    'py': round(robot_y, 2)
                },
                'bbox': region_data['bbox'],
                'corners': region_data.get('corners', []),
                'applied_region_offset': region_name  # L∆∞u t√™n region ƒë·ªÉ debug
            }
            
            # ‚≠ê IMPROVED BAG PALLET TRACKING LOGIC ‚≠ê
            if region_name == 'pallets1':
                # C√≥ P{pallet_id}R{region_id} ·ªü pallets1 ‚Üí update bag_pallet_1
                self.bag_pallet_1 = region_info['pallet_id']
                # ‚≠ê STRATEGY: S·ª≠ d·ª•ng center region (R2) l√†m representative ‚≠ê
                if region_info['region_id'] == 2:  # R2 l√† center region
                    self.current_region_data['pallets1'] = region_with_coords
                    if self.debug:
                        print(f"    üì¶ bag_pallet_1 = {self.bag_pallet_1} (Representative: P{region_info['pallet_id']}R{region_info['region_id']} ·ªü pallets1)")
                elif not self.current_region_data['pallets1']:  # Fallback n·∫øu ch∆∞a c√≥ R2
                    self.current_region_data['pallets1'] = region_with_coords
                    if self.debug:
                        print(f"    üì¶ bag_pallet_1 = {self.bag_pallet_1} (Fallback: P{region_info['pallet_id']}R{region_info['region_id']} ·ªü pallets1)")
                    
            elif region_name == 'pallets2':
                # C√≥ P{pallet_id}R{region_id} ·ªü pallets2 ‚Üí update bag_pallet_2 
                self.bag_pallet_2 = region_info['pallet_id']
                # ‚≠ê STRATEGY: S·ª≠ d·ª•ng center region (R2) l√†m representative ‚≠ê
                if region_info['region_id'] == 2:  # R2 l√† center region
                    self.current_region_data['pallets2'] = region_with_coords
                    if self.debug:
                        print(f"    üì¶ bag_pallet_2 = {self.bag_pallet_2} (Representative: P{region_info['pallet_id']}R{region_info['region_id']} ·ªü pallets2)")
                elif not self.current_region_data['pallets2']:  # Fallback n·∫øu ch∆∞a c√≥ R2
                    self.current_region_data['pallets2'] = region_with_coords
                    if self.debug:
                        print(f"    üì¶ bag_pallet_2 = {self.bag_pallet_2} (Fallback: P{region_info['pallet_id']}R{region_info['region_id']} ·ªü pallets2)")
                    
            elif region_name == 'loads':
                # Update loads region data - s·ª≠ d·ª•ng b·∫•t k·ª≥ region n√†o ·ªü loads workspace
                if not self.current_region_data['loads']:  # Ch·ªâ update n·∫øu ch∆∞a c√≥
                    self.current_region_data['loads'] = region_with_coords
                    if self.debug:
                        print(f"    üì¶ loads region updated (P{region_info['pallet_id']}R{region_info['region_id']} ·ªü loads)")
            
            regions_with_robot_coords.append(region_with_coords)
            
            if self.debug:
                print(f"  Region {region_info['region_id']} (Pallet {region_info['pallet_id']}): "
                      f"Pixel({center_pixel[0]:.1f}, {center_pixel[1]:.1f}) ‚Üí "
                      f"Robot(Px={robot_x:.2f}, Py={robot_y:.2f})")
        
        self.last_regions_data = regions_with_robot_coords
        return regions_with_robot_coords
    
    def _determine_region_name(self, center_pixel: Tuple[float, float], region_info: Dict) -> Optional[str]:
        """
        X√°c ƒë·ªãnh t√™n region trong RegionManager d·ª±a tr√™n v·ªã tr√≠ pixel v√† th√¥ng tin region
        
        Args:
            center_pixel: T·ªça ƒë·ªô pixel center c·ªßa region
            region_info: Th√¥ng tin region t·ª´ module division
            
        Returns:
            str: T√™n region trong RegionManager ho·∫∑c None
        """
        # ‚≠ê IMPROVED LOGIC: D·ª±a tr√™n pallet_id v√† v·ªã tr√≠ pixel ‚≠ê
        pallet_id = region_info.get('pallet_id', 0)
        region_id = region_info.get('region_id', 0)
        
        if self.debug:
            print(f"    üîç Mapping P{pallet_id}R{region_id} at pixel({center_pixel[0]:.1f}, {center_pixel[1]:.1f})")
        
        # ‚≠ê CHI·∫æN L∆Ø·ª¢C 1: D·ª±a tr√™n v·ªã tr√≠ pixel (PRIMARY) ‚≠ê
        # S·ª≠ d·ª•ng RegionManager ƒë·ªÉ x√°c ƒë·ªãnh region d·ª±a tr√™n v·ªã tr√≠
        for region_name in self.region_manager.regions.keys():
            if self.region_manager.is_point_in_region(center_pixel, region_name):
                if self.debug:
                    print(f"    ‚úÖ Pixel mapping: P{pallet_id}R{region_id} ‚Üí {region_name}")
                return region_name
        
        # ‚≠ê CHI·∫æN L∆Ø·ª¢C 2: D·ª±a tr√™n pallet position heuristic (FALLBACK) ‚≠ê
        # N·∫øu kh√¥ng t√¨m th·∫•y pixel mapping, d√πng heuristic d·ª±a tr√™n v·ªã tr√≠ X
        x_position = center_pixel[0]
        
        # Gi·∫£ ƒë·ªãnh layout: loads ·ªü gi·ªØa, pallets1 ·ªü tr√°i, pallets2 ·ªü ph·∫£i
        # (C√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh theo camera setup th·ª±c t·∫ø)
        if x_position < 400:  # V√πng tr√°i
            mapped_region = 'pallets1'
        elif x_position > 800:  # V√πng ph·∫£i
            mapped_region = 'pallets2'
        else:  # V√πng gi·ªØa
            mapped_region = 'loads'
        
        if self.debug:
            print(f"    üîÑ Heuristic mapping: P{pallet_id}R{region_id} (X={x_position:.0f}) ‚Üí {mapped_region}")
        
        return mapped_region
    
    def send_regions_to_plc(self, regions_data: List[Dict] = None) -> bool:
        """
        G·ª≠i t·ªça ƒë·ªô robot c·ªßa c√°c regions v√†o PLC DB26 theo BAG PALLET TRACKING
        
        Args:
            regions_data: DEPRECATED - Kh√¥ng s·ª≠ d·ª•ng, ch·ªâ ƒë·ªÉ backward compatibility
            
        Returns:
            bool: True n·∫øu g·ª≠i th√†nh c√¥ng t·∫•t c·∫£ regions
        """
        if not self.plc_connected:
            if self.debug:
                print(f"[RegionPLC] ‚ùå PLC ch∆∞a k·∫øt n·ªëi, b·ªè qua g·ª≠i d·ªØ li·ªáu")
            return False
        
        # ‚≠ê S·ª¨ D·ª§NG BAG PALLET TRACKING THAY V√å regions_data ‚≠ê
        regions_to_send = []
        
        # Ch·ªâ g·ª≠i c√°c region c√≥ d·ªØ li·ªáu th·ª±c t·∫ø
        for region_name, region_data in self.current_region_data.items():
            if region_data is not None:
                regions_to_send.append((region_name, region_data))
        
        if not regions_to_send:
            if self.debug:
                print(f"[RegionPLC] Kh√¥ng c√≥ region data ƒë·ªÉ g·ª≠i (current_region_data tr·ªëng)")
            return False
        
        if self.debug:
            print(f"[RegionPLC] ƒêang g·ª≠i {len(regions_to_send)} regions v√†o PLC theo BAG PALLET TRACKING...")
            print(f"  üì¶ bag_pallet_1={self.bag_pallet_1}, bag_pallet_2={self.bag_pallet_2}")
        
        success_count = 0
        total_writes = 0
        
        # G·ª≠i t·ªça ƒë·ªô theo t·ª´ng region ri√™ng bi·ªát
        for region_name, region_data in regions_to_send:
            if region_name in self.db26_offsets:
                offsets = self.db26_offsets[region_name]
                robot_coords = region_data['robot_coordinates']
                region_info = region_data
                
                px = robot_coords['px']
                py = robot_coords['py']
                
                # Ghi Px
                px_success = self.plc_comm.write_db26_real(offsets['px'], px)
                total_writes += 1
                if px_success:
                    success_count += 1
                
                # Ghi Py
                py_success = self.plc_comm.write_db26_real(offsets['py'], py)
                total_writes += 1
                if py_success:
                    success_count += 1
                
                if self.debug:
                    px_status = "‚úÖ" if px_success else "‚ùå"
                    py_status = "‚úÖ" if py_success else "‚ùå"
                    pallet_id = region_info.get('pallet_id', '?')
                    region_id = region_info.get('region_id', '?')
                    
                    print(f"  [{region_name}] P{pallet_id}R{region_id}: {px_status} Px={px:7.2f} (DB26.{offsets['px']}), "
                          f"{py_status} Py={py:7.2f} (DB26.{offsets['py']})")
            else:
                if self.debug:
                    print(f"  ‚ö†Ô∏è  B·ªè qua region kh√¥ng c√≥ offset: {region_name}")
        
        # Th√†nh c√¥ng n·∫øu t·∫•t c·∫£ writes ƒë·ªÅu OK
        all_success = success_count == total_writes
        
        if self.debug:
            if all_success:
                print(f"[RegionPLC] ‚úÖ ƒê√£ g·ª≠i th√†nh c√¥ng t·∫•t c·∫£ {total_writes} gi√° tr·ªã v√†o PLC")
            else:
                print(f"[RegionPLC] ‚ùå Ch·ªâ g·ª≠i th√†nh c√¥ng {success_count}/{total_writes} gi√° tr·ªã")
        
        return all_success
    
    def read_regions_from_plc(self) -> Dict[str, Dict]:
        """
        ƒê·ªçc l·∫°i t·ªça ƒë·ªô regions t·ª´ PLC ƒë·ªÉ verify
        
        Returns:
            Dict: T·ªça ƒë·ªô ƒë·ªçc ƒë∆∞·ª£c t·ª´ PLC
        """
        if not self.plc_connected:
            return {}
        
        plc_data = {}
        
        for region_name, offsets in self.db26_offsets.items():
            px = self.plc_comm.read_db26_real(offsets['px'])
            py = self.plc_comm.read_db26_real(offsets['py'])
            
            plc_data[region_name] = {
                'px': px,
                'py': py,
                'px_offset': offsets['px'],
                'py_offset': offsets['py']
            }
        
        return plc_data
    
    def process_detection_and_send_to_plc(self, detections: Dict[str, Any], layer: int = 1) -> Tuple[List[Dict], bool]:
        """
        ‚≠ê ENHANCED: S·ª≠ d·ª•ng depth results tr·ª±c ti·∫øp ƒë·ªÉ l·∫•y x,y,z coordinates ‚≠ê
        Workflow: Depth Results (x,y,z) ‚Üí Robot Transformation ‚Üí PLC
        
        Args:
            detections: K·∫øt qu·∫£ detection t·ª´ YOLO (bao g·ªìm c·∫£ depth results t·ª´ pipeline)
            layer: Layer ƒë·ªÉ chia
            
        Returns:
            Tuple[List[Dict], bool]: (regions_data, send_success)
        """
        if self.debug:
            print(f"\n[RegionPLC] üéØ NEW WORKFLOW: Using depth results directly")
        
        # ‚≠ê STEP 1: L·∫•y depth results t·ª´ pipeline (CH√çNH X√ÅC) ‚≠ê
        # Access depth results t·ª´ detection pipeline thay v√¨ t·ª± t·∫°o
        depth_results = detections.get('depth_results')
        pallet_regions = detections.get('pallet_regions', [])
        
        if not depth_results and not pallet_regions:
            if self.debug:
                print(f"[RegionPLC] ‚ùå Kh√¥ng c√≥ depth_results ho·∫∑c pallet_regions t·ª´ pipeline!")
            return [], False
        
        if self.debug:
            print(f"[RegionPLC] üìä Input data: depth_results={len(depth_results) if depth_results else 0}, pallet_regions={len(pallet_regions)}")
        
        # ‚≠ê STEP 2: S·ª≠ d·ª•ng depth results n·∫øu c√≥, fallback v·ªÅ pallet_regions ‚≠ê
        source_data = depth_results if depth_results else pallet_regions
        data_source = "depth_results" if depth_results else "pallet_regions"
        
        if self.debug:
            print(f"[RegionPLC] üîÑ Using {data_source} with {len(source_data)} regions")
        
        # ‚≠ê STEP 3: Process depth results theo bag mapping ‚≠ê
        self._detections_context = detections  # ‚≠ê Store for fallback access ‚≠ê
        self._process_depth_results_to_plc(source_data, data_source)
        
        # ‚≠ê STEP 4: G·ª≠i v√†o PLC theo bag pallet tracking ‚≠ê
        send_success = self.send_regions_to_plc()
        
        return source_data, send_success
    
    def _process_depth_results_to_plc(self, source_data: List[Dict], data_source: str):
        """
        ‚≠ê NEW: Process depth results theo bag mapping ‚≠ê
        
        Args:
            source_data: Depth results or pallet regions
            data_source: Source of the data (depth_results or pallet_regions)
        """
        if self.debug:
            print(f"[RegionPLC] üìã {data_source} data:")
            for i, region_data in enumerate(source_data):
                region_info = region_data.get('region_info', {})
                pallet_id = region_info.get('pallet_id', 'MISSING')
                region_id = region_info.get('region_id', 'MISSING')
                print(f"  {i}: P{pallet_id}R{region_id}")
        
        # ‚≠ê RESET CURRENT REGION DATA ‚≠ê
        self.current_region_data = {
            'loads': None,
            'pallets1': None,
            'pallets2': None
        }
        
        # ‚≠ê ENHANCED: BAG POSITION MAPPING WITH REGION LOOKUP ‚≠ê
        # Map bag number to actual region coordinates from source_data
        target_region_id = self.bag_to_region_mapping.get(self.current_bag_number, 1)
        
        if self.debug:
            print(f"[RegionPLC] üéØ Current bag {self.current_bag_number} ‚Üí Target region R{target_region_id}")
            print(f"[RegionPLC] üìä Bag mapping: {self.bag_to_region_mapping}")
        
        # ‚≠ê STEP 1: Populate pallets1/pallets2 t·ª´ depth results (ch√≠nh x√°c) ‚≠ê
        self._populate_pallet_regions_from_source_data(source_data, target_region_id, data_source)
        
        # ‚≠ê STEP 2: Populate loads t·ª´ source_data ho·∫∑c robot_coordinates ‚≠ê
        # Depth results th∆∞·ªùng ch·ªâ c√≥ pallet regions, loads c√≥ th·ªÉ ·ªü robot_coordinates
        loads_found = self._populate_loads_from_source_data(source_data, data_source)
        
        # ‚≠ê FALLBACK: N·∫øu kh√¥ng t√¨m th·∫•y loads trong depth results, th·ª≠ robot_coordinates ‚≠ê
        if not loads_found and hasattr(self, '_detections_context'):
            robot_coordinates = self._detections_context.get('robot_coordinates', [])
            if robot_coordinates:
                if self.debug:
                    print(f"[RegionPLC] üîÑ Fallback: Using robot_coordinates for loads...")
                self._populate_loads_from_robot_coordinates(robot_coordinates)
        
        # ‚≠ê DEBUG: Show final region data ‚≠ê
        if self.debug:
            print(f"\n[RegionPLC] üìä Final region data:")
            for region_name, region_data in self.current_region_data.items():
                if region_data:
                    px = region_data['robot_coordinates']['px']
                    py = region_data['robot_coordinates']['py']
                    source = region_data.get('coordinate_source', 'unknown')
                    print(f"  {region_name}: Px={px:.2f}, Py={py:.2f} ({source})")
                else:
                    print(f"  {region_name}: EMPTY")
    
    def _populate_pallet_regions_from_source_data(self, source_data: List[Dict], target_region_id: int, data_source: str):
        """
        ‚≠ê NEW: Populate pallets1/pallets2 t·ª´ source_data (ƒê√öNG) ‚≠ê
        
        Args:
            source_data: Depth results or pallet regions
            target_region_id: Target region ID based on bag mapping
            data_source: Source of the data (depth_results or pallet_regions)
        """
        # ‚≠ê FORCE DEBUG ƒë·ªÉ t√¨m hi·ªÉu v·∫•n ƒë·ªÅ ‚≠ê
        print(f"\n[RegionPLC] üè≠ POPULATING PALLET REGIONS from source_data...")
        print(f"[RegionPLC] üéØ Looking for P1R{target_region_id} and P2R{target_region_id}...")
        print(f"[RegionPLC] üìã source_data count: {len(source_data)}")
        
        # Find P1R{target_region_id} for pallets1
        for i, region_data in enumerate(source_data):
            region_info = region_data.get('region_info', {})
            pallet_id = region_info.get('pallet_id')
            region_id = region_info.get('region_id')
            
            print(f"  Region {i}: P{pallet_id}R{region_id}")
            
            if pallet_id == 1 and region_id == target_region_id:
                # Found P1R{target_region_id} for pallets1
                
                # ‚≠ê USE DEPTH COORDINATES thay v√¨ pixel coordinates ‚≠ê
                robot_x, robot_y = self._extract_robot_coordinates_from_region(region_data, data_source)
                
                self.current_region_data['pallets1'] = {
                    'region_id': target_region_id,
                    'pallet_id': 1,
                    'robot_coordinates': {'px': robot_x, 'py': robot_y},
                    'pixel_center': region_data.get('center', [0, 0]),
                    'class': 'pallet',
                    'bag_number': self.current_bag_number,
                    'sequence_mapping': f"bao {self.current_bag_number} ‚Üí P1R{target_region_id}",
                    'coordinate_source': f'{data_source}_P1R{target_region_id}',
                    'depth_info': region_data.get('position', {}),  # ‚≠ê Store depth info ‚≠ê
                    'camera_3d': region_data.get('position_3d_camera', {})  # ‚≠ê Store 3D camera coords ‚≠ê
                }
                
                self.bag_pallet_1 = 1
                
                print(f"    ‚úÖ FOUND P1R{target_region_id} for pallets1: robot=({robot_x:.2f}, {robot_y:.2f}) from {data_source}")
            
            elif pallet_id == 2 and region_id == target_region_id:
                # Found P2R{target_region_id} for pallets2
                
                # ‚≠ê USE DEPTH COORDINATES thay v√¨ pixel coordinates ‚≠ê
                robot_x, robot_y = self._extract_robot_coordinates_from_region(region_data, data_source)
                
                self.current_region_data['pallets2'] = {
                    'region_id': target_region_id,
                    'pallet_id': 2,
                    'robot_coordinates': {'px': robot_x, 'py': robot_y},
                    'pixel_center': region_data.get('center', [0, 0]),
                    'class': 'pallet',
                    'bag_number': self.current_bag_number,
                    'sequence_mapping': f"bao {self.current_bag_number} ‚Üí P2R{target_region_id}",
                    'coordinate_source': f'{data_source}_P2R{target_region_id}',
                    'depth_info': region_data.get('position', {}),  # ‚≠ê Store depth info ‚≠ê
                    'camera_3d': region_data.get('position_3d_camera', {})  # ‚≠ê Store 3D camera coords ‚≠ê
                }
                
                self.bag_pallet_2 = 2
                
                print(f"    ‚úÖ FOUND P2R{target_region_id} for pallets2: robot=({robot_x:.2f}, {robot_y:.2f}) from {data_source}")
        
        # Check results
        pallets1_status = "‚úÖ FOUND" if self.current_region_data['pallets1'] else "‚ùå NOT FOUND"
        pallets2_status = "‚úÖ FOUND" if self.current_region_data['pallets2'] else "‚ùå NOT FOUND"
        print(f"[RegionPLC] üìä Pallet regions status: pallets1={pallets1_status}, pallets2={pallets2_status}")
        
        # ‚≠ê DEBUG: Show final pallet coordinates ‚≠ê
        if self.current_region_data['pallets1']:
            px1 = self.current_region_data['pallets1']['robot_coordinates']['px']
            py1 = self.current_region_data['pallets1']['robot_coordinates']['py']
            print(f"[RegionPLC] üéØ pallets1 final: P1R{target_region_id} ‚Üí Px={px1:.2f}, Py={py1:.2f}")
        
        if self.current_region_data['pallets2']:
            px2 = self.current_region_data['pallets2']['robot_coordinates']['px']
            py2 = self.current_region_data['pallets2']['robot_coordinates']['py']
            print(f"[RegionPLC] üéØ pallets2 final: P2R{target_region_id} ‚Üí Px={px2:.2f}, Py={py2:.2f}")
    
    def _populate_loads_from_source_data(self, source_data: List[Dict], data_source: str) -> bool:
        """
        ‚≠ê NEW: Populate loads t·ª´ source_data v·ªõi IMPROVED detection logic ‚≠ê
        
        Args:
            source_data: Depth results or pallet regions
            data_source: Source of the data (depth_results or pallet_regions)
            
        Returns:
            bool: True if loads was found and populated
        """
        print(f"\n[RegionPLC] üì¶ POPULATING LOADS REGION from {data_source}...")
        print(f"[RegionPLC] üìã source_data count: {len(source_data)}")
        
        # ‚≠ê IMPROVED LOAD DETECTION LOGIC ‚≠ê
        for i, region_data in enumerate(source_data):
            region_info = region_data.get('region_info', {})
            object_class = region_info.get('object_class', '')
            pallet_id = region_info.get('pallet_id', 0)
            
            # Convert numeric class to string for comparison
            if isinstance(object_class, (int, float)):
                object_class = str(object_class)
            
            print(f"  Region {i}: object_class='{object_class}', pallet_id={pallet_id}")
            
            # ‚≠ê LOGIC 1: Non-pallet objects (pallet_id = 0) ‚≠ê
            if pallet_id == 0 and object_class in ['load', 'load2', '0.0', '1.0', 0.0, 1.0]:
                # ‚≠ê NEW: Th√™m region filtering ƒë·ªÉ ƒë·∫£m b·∫£o load kh√¥ng n·∫±m trong pallets region ‚≠ê
                center = region_data.get('center', [0, 0])
                is_in_loads_region = self.region_manager.is_point_in_region((center[0], center[1]), 'loads')
                is_in_pallets1 = self.region_manager.is_point_in_region((center[0], center[1]), 'pallets1')
                is_in_pallets2 = self.region_manager.is_point_in_region((center[0], center[1]), 'pallets2')
                
                # ‚≠ê CH·ªà NH·∫¨N LOAD N·∫æU: pallet_id=0 V√Ä KH√îNG n·∫±m trong pallets1/pallets2 ‚≠ê
                if not is_in_pallets1 and not is_in_pallets2:
                    # Extract coordinates v·ªõi robot transform + region offsets
                    robot_x, robot_y = self._extract_robot_coordinates_from_region(region_data, data_source)
                    
                    self.current_region_data['loads'] = {
                        'region_id': 1,  # Default loads region ID
                        'pallet_id': 1,  # Default loads pallet ID for PLC
                        'robot_coordinates': {'px': robot_x, 'py': robot_y},
                        'pixel_center': center,
                        'class': object_class,
                        'bag_number': self.current_bag_number,
                        'sequence_mapping': f"loads ‚Üí {object_class} detection (filtered)",
                        'coordinate_source': f'{data_source}_load_filtered_{object_class}',
                        'depth_info': region_data.get('position', {}),
                        'depth_value': region_data.get('position', {}).get('z', 0.0)  # Depth t·ª´ depth module
                    }
                    
                    region_info = "loads" if is_in_loads_region else "general"
                    print(f"    ‚úÖ FOUND {object_class} (pallet_id=0) in {region_info} area: robot=({robot_x:.2f}, {robot_y:.2f})")
                    return True
                else:
                    # ‚≠ê LOG: Load v·ªõi pallet_id=0 nh∆∞ng n·∫±m trong pallet region (ƒë√£ ƒë∆∞·ª£c robot pick) ‚≠ê
                    pallet_region = "pallets1" if is_in_pallets1 else "pallets2" 
                    print(f"    üö´ SKIPPED {object_class} (pallet_id=0) in {pallet_region} (robot already processed)")
            
            # ‚≠ê LOGIC 2: Load objects ƒë∆∞·ª£c assigned v√†o loads region th√¥ng qua RegionManager ‚≠ê
            elif object_class in ['load', 'load2', '0.0', '1.0', 0.0, 1.0]:
                # Ki·ªÉm tra xem object c√≥ n·∫±m trong loads region kh√¥ng
                center = region_data.get('center', [0, 0])
                is_in_loads_region = self.region_manager.is_point_in_region((center[0], center[1]), 'loads')
                
                # ‚≠ê NEW: Ki·ªÉm tra load KH√îNG n·∫±m trong pallets1 ƒë·ªÉ tr√°nh nh·∫≠n nh·∫ßm load ƒë√£ ƒë∆∞·ª£c robot pick ‚≠ê
                is_in_pallets1 = self.region_manager.is_point_in_region((center[0], center[1]), 'pallets1')
                is_in_pallets2 = self.region_manager.is_point_in_region((center[0], center[1]), 'pallets2')
                
                # ‚≠ê CH·ªà NH·∫¨N LOAD N·∫æU: n·∫±m trong loads region V√Ä KH√îNG n·∫±m trong pallets1/pallets2 ‚≠ê
                if is_in_loads_region and not is_in_pallets1 and not is_in_pallets2:
                    # Extract coordinates v·ªõi robot transform + region offsets
                    robot_x, robot_y = self._extract_robot_coordinates_from_region(region_data, data_source)
                    
                    self.current_region_data['loads'] = {
                        'region_id': 1,  # Default loads region ID
                        'pallet_id': 1,  # Default loads pallet ID for PLC
                        'robot_coordinates': {'px': robot_x, 'py': robot_y},
                        'pixel_center': center,
                        'class': object_class,
                        'bag_number': self.current_bag_number,
                        'sequence_mapping': f"loads ‚Üí {object_class} in loads region only",
                        'coordinate_source': f'{data_source}_loads_region_filtered_{object_class}',
                        'depth_info': region_data.get('position', {}),
                        'depth_value': region_data.get('position', {}).get('z', 0.0)  # Depth t·ª´ depth module
                    }
                    
                    print(f"    ‚úÖ FOUND {object_class} in loads region (excluded from pallets): robot=({robot_x:.2f}, {robot_y:.2f})")
                    return True
                elif is_in_pallets1 or is_in_pallets2:
                    # ‚≠ê LOG: Load ƒë√£ ƒë∆∞·ª£c robot pick v√†o pallet region ‚≠ê
                    pallet_region = "pallets1" if is_in_pallets1 else "pallets2"
                    print(f"    üö´ SKIPPED {object_class} in {pallet_region} (already processed by robot)")
                elif not is_in_loads_region:
                    # ‚≠ê LOG: Load kh√¥ng n·∫±m trong loads region ‚≠ê
                    print(f"    ‚ö†Ô∏è SKIPPED {object_class} outside loads region")
                else:
                    print(f"    ‚ùì SKIPPED {object_class} (unknown filtering reason)")
        
        print(f"    ‚ùå NO LOAD DETECTION found for loads region")
        return False
    
    def _populate_loads_from_robot_coordinates(self, robot_coordinates: List[Dict]):
        """
        ‚≠ê NEW: Populate loads t·ª´ robot_coordinates (fallback) ‚≠ê
        
        Args:
            robot_coordinates: Robot coordinates t·ª´ pipeline
        """
        print(f"\n[RegionPLC] üì¶ POPULATING LOADS from robot_coordinates...")
        print(f"[RegionPLC] üìã robot_coordinates count: {len(robot_coordinates)}")
        
        # T√¨m load detection t·ª´ robot_coordinates
        load_classes = ['load', 'load2']
        for i, coord in enumerate(robot_coordinates):
            coord_class = coord.get('class', '')
            print(f"  Coord {i}: {coord_class}")
            
            if coord_class in load_classes:
                # ‚≠ê NEW: Ki·ªÉm tra v·ªã tr√≠ pixel ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng n·∫±m trong pallets region ‚≠ê
                camera_pixel = coord.get('camera_pixel', {})
                center = (camera_pixel.get('x', 0), camera_pixel.get('y', 0))
                
                is_in_loads_region = self.region_manager.is_point_in_region(center, 'loads')
                is_in_pallets1 = self.region_manager.is_point_in_region(center, 'pallets1')
                is_in_pallets2 = self.region_manager.is_point_in_region(center, 'pallets2')
                
                # ‚≠ê CH·ªà NH·∫¨N LOAD N·∫æU: KH√îNG n·∫±m trong pallets1/pallets2 ‚≠ê
                if not is_in_pallets1 and not is_in_pallets2:
                    robot_pos = coord['robot_coordinates']
                    
                    self.current_region_data['loads'] = {
                        'region_id': 1,  # Default loads region ID
                        'pallet_id': 1,  # Default loads pallet ID
                        'robot_coordinates': {
                            'px': robot_pos['x'],
                            'py': robot_pos['y']
                        },
                        'pixel_center': [center[0], center[1]],
                        'class': coord_class,
                        'bag_number': self.current_bag_number,
                        'sequence_mapping': f"loads ‚Üí {coord_class} detection (filtered)",
                        'coordinate_source': f'robot_coordinates_load_filtered_{coord_class}'
                    }
                    
                    region_info = "loads" if is_in_loads_region else "general"
                    print(f"    ‚úÖ FOUND {coord_class} in {region_info} area: robot=({robot_pos['x']:.2f}, {robot_pos['y']:.2f})")
                    return  # Exit after finding first valid load
                else:
                    # ‚≠ê LOG: Load n·∫±m trong pallet region (ƒë√£ ƒë∆∞·ª£c robot pick) ‚≠ê
                    pallet_region = "pallets1" if is_in_pallets1 else "pallets2"
                    robot_pos = coord['robot_coordinates']
                    print(f"    üö´ SKIPPED {coord_class} in {pallet_region} (robot already processed): robot=({robot_pos['x']:.2f}, {robot_pos['y']:.2f})")
        
        print(f"    ‚ùå NO VALID LOAD DETECTION found in robot_coordinates (excluding pallets regions)")
    
    def set_current_bag_number(self, bag_number: int, send_to_plc: bool = True):
        """
        ‚≠ê NEW: Set current bag number v√† g·ª≠i v√†o PLC ‚≠ê
        
        Args:
            bag_number: Bag number (1, 2, ho·∫∑c 3)
            send_to_plc: C√≥ g·ª≠i bag number v√†o PLC kh√¥ng
        """
        if bag_number in self.bag_to_region_mapping:
            old_bag = self.current_bag_number
            self.current_bag_number = bag_number
            target_region = self.bag_to_region_mapping[bag_number]
            
            # G·ª≠i bag number v√†o PLC n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
            if send_to_plc:
                self.send_bag_number_to_plc(bag_number)
            
            if self.debug:
                print(f"üéØ [BAG CONTROL] Switched: bao {old_bag} ‚Üí bao {bag_number} (maps to R{target_region})")
                print(f"   Sequence mapping: {self.bag_to_region_mapping}")
        else:
            if self.debug:
                print(f"‚ùå [BAG CONTROL] Invalid bag number: {bag_number}. Valid: {list(self.bag_to_region_mapping.keys())}")
    
    def send_bag_number_to_plc(self, bag_number: int) -> bool:
        """
        ‚≠ê NEW: G·ª≠i bag number v√†o PLC t·∫°i DB26.40 ‚≠ê
        
        Args:
            bag_number: Bag number (1, 2, ho·∫∑c 3)
            
        Returns:
            bool: True n·∫øu g·ª≠i th√†nh c√¥ng
        """
        if not self.plc_connected:
            if self.debug:
                print(f"[RegionPLC] ‚ö†Ô∏è PLC ch∆∞a k·∫øt n·ªëi, kh√¥ng th·ªÉ g·ª≠i bag number")
            return False
        
        try:
            offset = self.db26_offsets['bag_number']['offset']
            success = self.plc_comm.write_db26_int(offset, bag_number)
            
            if self.debug:
                if success:
                    print(f"[RegionPLC] ‚úÖ ƒê√£ g·ª≠i bag_number={bag_number} v√†o DB26.{offset}")
                else:
                    print(f"[RegionPLC] ‚ùå L·ªói g·ª≠i bag_number={bag_number} v√†o DB26.{offset}")
            
            return success
            
        except Exception as e:
            if self.debug:
                print(f"[RegionPLC] ‚ùå Exception khi g·ª≠i bag_number: {e}")
            return False
    
    def get_current_bag_info(self) -> Dict[str, Any]:
        """
        ‚≠ê NEW: Get current bag information ‚≠ê
        
        Returns:
            Dict: Current bag info v√† mapping
        """
        target_region = self.bag_to_region_mapping.get(self.current_bag_number, 1)
        return {
            'current_bag_number': self.current_bag_number,
            'target_region_id': target_region,
            'sequence_mapping': f"bao {self.current_bag_number} ‚Üí R{target_region}",
            'all_mappings': self.bag_to_region_mapping.copy()
        }
    
    def get_bag_pallet_status(self) -> Dict[str, Any]:
        """
        L·∫•y tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa bag pallet tracking
        
        Returns:
            Dict: Th√¥ng tin bag pallet status
        """
        status = {
            'bag_pallet_1': self.bag_pallet_1,
            'bag_pallet_2': self.bag_pallet_2,
            'current_regions': {},
            'active_regions_count': 0,
            'current_bag_info': self.get_current_bag_info()  # ‚≠ê NEW: Add bag info ‚≠ê
        }
        
        for region_name, region_data in self.current_region_data.items():
            if region_data is not None:
                status['current_regions'][region_name] = {
                    'pallet_id': region_data.get('pallet_id'),
                    'region_id': region_data.get('region_id'), 
                    'robot_coords': region_data.get('robot_coordinates'),
                    'pixel_center': region_data.get('pixel_center'),
                    'bag_number': region_data.get('bag_number'),  # ‚≠ê NEW: Add bag info ‚≠ê
                    'sequence_mapping': region_data.get('sequence_mapping')  # ‚≠ê NEW: Add mapping info ‚≠ê
                }
                status['active_regions_count'] += 1
            else:
                status['current_regions'][region_name] = None
        
        return status
    
    # ‚≠ê ENHANCED VISUALIZATION WITH COMPLETED REGIONS ‚≠ê
    def create_visualization(self, image: np.ndarray, regions_data: List[Dict] = None, 
                           completed_regions: List[str] = None) -> np.ndarray:
        """
        ‚≠ê ENHANCED: T·∫°o visualization cho regions v·ªõi robot coordinates + completed status ‚≠ê
        
        Args:
            image: ·∫¢nh g·ªëc
            regions_data: Danh s√°ch regions v·ªõi robot coordinates (optional)
            completed_regions: List t√™n regions ƒë√£ ho√†n th√†nh (e.g. ['P1R1', 'P1R2'])
            
        Returns:
            np.ndarray: ·∫¢nh ƒë√£ v·∫Ω visualization
        """
        result_image = image.copy()
        
        # S·ª≠ d·ª•ng last_regions_data n·∫øu kh√¥ng c√≥ regions_data
        if regions_data is None:
            regions_data = self.last_regions_data
        
        if not regions_data:
            # V·∫Ω status c∆° b·∫£n n·∫øu kh√¥ng c√≥ regions
            cv2.putText(result_image, "Waiting for regions...", (10, 50), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
            return result_image
        
        # ‚≠ê ENHANCED: M√†u s·∫Øc cho regions v·ªõi completed status ‚≠ê
        def get_region_color(region_data, completed_regions):
            """Get color based on completion status"""
            if completed_regions:
                region_id = region_data.get('region_id', 0)
                pallet_id = region_data.get('pallet_id', 0)
                region_name = f"P{pallet_id}R{region_id}"
                
                if region_name in completed_regions:
                    return (0, 255, 0)  # üü¢ Xanh l√° - Ho√†n th√†nh
                else:
                    return (0, 255, 255)  # üü° V√†ng - ƒêang ch·ªù/ƒêang x·ª≠ l√Ω
            else:
                # Default colors khi kh√¥ng c√≥ completed info
                return [(0, 255, 0), (255, 0, 0), (0, 0, 255)][region_data.get('region_id', 1) % 3]
        
        # V·∫Ω t·ª´ng region
        for i, region_data in enumerate(regions_data):
            color = get_region_color(region_data, completed_regions)
            
            # V·∫Ω region boundary
            if 'corners' in region_data and region_data['corners']:
                corners = region_data['corners']
                pts = np.array(corners, np.int32)
                pts = pts.reshape((-1, 1, 2))
                cv2.polylines(result_image, [pts], True, color, 3)
            else:
                # Fallback: v·∫Ω bbox
                bbox = region_data['bbox']
                x1, y1, x2, y2 = [int(v) for v in bbox]
                cv2.rectangle(result_image, (x1, y1), (x2, y2), color, 3)
            
            # V·∫Ω center point
            center = region_data['pixel_center']
            cv2.circle(result_image, (int(center[0]), int(center[1])), 8, color, -1)
            
            # ‚≠ê ENHANCED: Hi·ªÉn th·ªã completion status ‚≠ê
            robot_coords = region_data['robot_coordinates']
            region_id = region_data['region_id']
            pallet_id = region_data['pallet_id']
            applied_offset = region_data.get('applied_region_offset', 'unknown')
            
            # Check completion status
            region_name = f"P{pallet_id}R{region_id}"
            is_completed = completed_regions and region_name in completed_regions
            status_icon = "‚úÖ" if is_completed else "‚è≥"
            
            text_lines = [
                f"{status_icon} [{applied_offset}]",    # Status + Region name
                f"P{pallet_id}R{region_id}",            # Pallet/Region ID
                f"Px:{robot_coords['px']:.1f}",         # Robot X coordinate
                f"Py:{robot_coords['py']:.1f}"          # Robot Y coordinate
            ]
            
            # V·∫Ω t·ª´ng d√≤ng text
            for j, text in enumerate(text_lines):
                text_y = int(center[1]) - 40 + j * 20
                text_size = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)[0]
                
                # Background cho text v·ªõi m√†u t∆∞∆°ng ·ª©ng completion status
                bg_color = (0, 100, 0) if is_completed else (0, 0, 0)  # Xanh ƒë·∫≠m n·∫øu completed
                cv2.rectangle(result_image,
                            (int(center[0]) - text_size[0]//2 - 2, text_y - text_size[1] - 2),
                            (int(center[0]) + text_size[0]//2 + 2, text_y + 2),
                            bg_color, -1)
                
                # Text color
                text_color = (255, 255, 255) if not is_completed else (200, 255, 200)  # Xanh nh·∫°t n·∫øu completed
                cv2.putText(result_image, text,
                          (int(center[0]) - text_size[0]//2, text_y),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.6, text_color, 2)
        
        # ‚≠ê V·∫º BAG PALLET STATUS V√Ä COMPLETION STATISTICS ‚≠ê
        status_y = 30
        status_text = [
            f"PLC: {'üü¢ Connected' if self.plc_connected else 'üî¥ Disconnected'}",
            f"BAG PALLET TRACKING:",
            f"bag_pallet_1 = {self.bag_pallet_1}",
            f"bag_pallet_2 = {self.bag_pallet_2}",
            f"Regions: {len(regions_data)} | Active: {sum(1 for x in self.current_region_data.values() if x is not None)}"
        ]
        
        # ‚≠ê TH√äM COMPLETION STATISTICS ‚≠ê
        if completed_regions:
            total_expected = len(regions_data)  # T·ªïng regions d·ª± ki·∫øn
            completed_count = len(completed_regions)
            progress_text = f"Progress: {completed_count}/{total_expected} ‚úÖ"
            status_text.append(progress_text)
            
            # Hi·ªÉn th·ªã completed regions
            if completed_count > 0:
                completed_str = ", ".join(completed_regions)
                status_text.append(f"Completed: {completed_str}")
        
        # V·∫Ω status text
        for i, text in enumerate(status_text):
            text_size = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)[0]
            
            # Background cho text
            cv2.rectangle(result_image,
                        (10 - 2, status_y + i * 20 - text_size[1] - 2),
                        (10 + text_size[0] + 2, status_y + i * 20 + 2),
                        (0, 0, 0), -1)
            
            # Ch·ªçn m√†u text
            if "üü¢" in text or "‚úÖ" in text:
                color = (0, 255, 0)  # Xanh l√°
            elif "üî¥" in text or "Progress:" in text:
                color = (255, 255, 0)  # V√†ng
            else:
                color = (255, 255, 255)  # Tr·∫Øng
            
            cv2.putText(result_image, text,
                      (10, status_y + i * 20),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
        
        return result_image

    def create_bag_tracking_visualization(self, frame, regions_data: List[Dict]):
        """
        ‚≠ê NEW: Create bag tracking visualization ƒë·ªÉ hi·ªÉn th·ªã bag status ‚≠ê
        
        Args:
            frame: Frame g·ªëc
            regions_data: Regions t·ª´ module division
            
        Returns:
            np.ndarray: Frame v·ªõi bag tracking info
        """
        viz_frame = frame.copy()
        
        # ‚≠ê DRAW CURRENT BAG INFO ‚≠ê
        bag_info = self.get_current_bag_info()
        current_mapping = bag_info['sequence_mapping']
        target_region_id = self.bag_to_region_mapping.get(self.current_bag_number, 1)
        
        # Background cho header
        cv2.rectangle(viz_frame, (10, 10), (600, 100), (0, 0, 0), -1)
        cv2.rectangle(viz_frame, (10, 10), (600, 100), (255, 255, 255), 2)
        
        # Header text
        cv2.putText(viz_frame, "BAG PALLET TRACKING", (20, 35), 
                   cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)
        cv2.putText(viz_frame, current_mapping, (20, 65), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
        cv2.putText(viz_frame, f"Target: P1R{target_region_id}, P2R{target_region_id}", (20, 85), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (128, 255, 128), 1)
        
        # ‚≠ê HIGHLIGHT TARGET REGIONS ‚≠ê
        if regions_data:
            for i, region_data in enumerate(regions_data):
                region_info = region_data.get('region_info', {})
                pallet_id = region_info.get('pallet_id')
                region_id = region_info.get('region_id')
                
                # Check if this is target region for current bag
                is_target = region_id == target_region_id
                
                if 'center' in region_data:
                    center = region_data['center']
                    center_x, center_y = int(center[0]), int(center[1])
                    
                    # Color based on target status
                    if is_target:
                        color = (0, 255, 255)  # Yellow for target regions
                        thickness = 4
                        label = f"P{pallet_id}R{region_id} [TARGET]"
                    else:
                        color = (128, 128, 128)  # Gray for non-target
                        thickness = 2
                        label = f"P{pallet_id}R{region_id}"
                    
                    # Draw region boundary
                    if 'corners' in region_data and region_data['corners']:
                        corners = region_data['corners']
                        pts = np.array(corners, np.int32)
                        pts = pts.reshape((-1, 1, 2))
                        cv2.polylines(viz_frame, [pts], True, color, thickness)
                    elif 'bbox' in region_data:
                        bbox = region_data['bbox']
                        x1, y1, x2, y2 = [int(v) for v in bbox]
                        cv2.rectangle(viz_frame, (x1, y1), (x2, y2), color, thickness)
                    
                    # Draw center point
                    cv2.circle(viz_frame, (center_x, center_y), 8, color, -1)
                    
                    # Draw label with background
                    text_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)[0]
                    cv2.rectangle(viz_frame,
                                (center_x - text_size[0]//2 - 5, center_y - 30 - text_size[1] - 5),
                                (center_x + text_size[0]//2 + 5, center_y - 30 + 5),
                                (0, 0, 0), -1)
                    cv2.putText(viz_frame, label,
                              (center_x - text_size[0]//2, center_y - 30),
                              cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
        
        # ‚≠ê DRAW CURRENT REGION DATA STATUS ‚≠ê
        y_offset = 120
        line_height = 25
        
        status_lines = [
            "=== CURRENT REGION DATA ===",
            f"bag_pallet_1 = {self.bag_pallet_1}",
            f"bag_pallet_2 = {self.bag_pallet_2}",
        ]
        
        # Add region status
        for region_name in ['loads', 'pallets1', 'pallets2']:
            region_data = self.current_region_data.get(region_name)
            if region_data:
                px = region_data['robot_coordinates']['px']
                py = region_data['robot_coordinates']['py']
                source = region_data.get('coordinate_source', 'unknown')
                status_lines.append(f"{region_name}: Px={px:.2f}, Py={py:.2f} ({source})")
            else:
                status_lines.append(f"{region_name}: EMPTY")
        
        # Draw status with background
        for i, line in enumerate(status_lines):
            y_pos = y_offset + i * line_height
            text_size = cv2.getTextSize(line, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)[0]
            
            # Background
            cv2.rectangle(viz_frame,
                        (10 - 2, y_pos - text_size[1] - 2),
                        (10 + text_size[0] + 2, y_pos + 2),
                        (0, 0, 0), -1)
            
            # Text color
            if i == 0:  # Header
                color = (0, 255, 255)  # Yellow
            elif "TARGET" in line:
                color = (0, 255, 255)  # Yellow for target
            elif "EMPTY" in line:
                color = (0, 0, 255)    # Red for empty
            else:
                color = (255, 255, 255)  # White
            
            cv2.putText(viz_frame, line, (10, y_pos),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
        
        # ‚≠ê DRAW BAG CONTROLS ‚≠ê
        controls_y = y_offset + len(status_lines) * line_height + 20
        control_lines = [
            "=== BAG CONTROLS ===",
            "Press '1': Set bao 1 ‚Üí R1",
            "Press '2': Set bao 2 ‚Üí R3", 
            "Press '3': Set bao 3 ‚Üí R2",
            "Press 'n': Send to PLC",
        ]
        
        for i, line in enumerate(control_lines):
            y_pos = controls_y + i * 20
            text_size = cv2.getTextSize(line, cv2.FONT_HERSHEY_SIMPLEX, 0.4, 1)[0]
            
            # Background
            cv2.rectangle(viz_frame,
                        (10 - 2, y_pos - text_size[1] - 2),
                        (10 + text_size[0] + 2, y_pos + 2),
                        (0, 0, 0), -1)
            
            # Text color
            color = (255, 255, 0) if i == 0 else (128, 255, 128)  # Yellow header, green controls
            
            cv2.putText(viz_frame, line, (10, y_pos),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)
        
        return viz_frame

    def _extract_robot_coordinates_from_region(self, region_data: Dict, data_source: str) -> Tuple[float, float]:
        """
        ‚≠ê Extract robot coordinates from region data v·ªõi ƒê√öNG robot transform + region offsets ‚≠ê
        
        Args:
            region_data: Region data from source_data
            data_source: Source of the data (depth_results or pallet_regions)
            
        Returns:
            Tuple[float, float]: Robot coordinates (x, y) ƒë√£ √°p d·ª•ng region offsets
        """
        if self.debug:
            print(f"    [EXTRACT] Processing {data_source} data...")
        
        # ‚≠ê STRATEGY 1: Use depth position + robot transformation + region offsets ‚≠ê
        if 'position' in region_data:
            position = region_data['position']
            pixel_x = position.get('x', 0.0)  # Pixel X t·ª´ depth results
            pixel_y = position.get('y', 0.0)  # Pixel Y t·ª´ depth results
            depth_z = position.get('z', 2.0)  # Depth Z t·ª´ depth module (kh√¥ng d√πng cho t·ªça ƒë·ªô)
            
            # Transform pixel coordinates to robot coordinates
            raw_robot_x, raw_robot_y = self.robot_transformer.camera_to_robot(pixel_x, pixel_y)
            
            # ‚≠ê X√ÅC ƒê·ªäNH REGION V√Ä √ÅP D·ª§NG OFFSET ‚≠ê
            region_name = self._determine_region_for_coordinates((pixel_x, pixel_y), region_data)
            if region_name and region_name in self.region_manager.regions:
                offset = self.region_manager.regions[region_name]['offset']
                final_robot_x = raw_robot_x + offset['x']
                final_robot_y = raw_robot_y + offset['y']
                
                if self.debug:
                    print(f"      Using position + robot_transform + {region_name} offset:")
                    print(f"        pixel=({pixel_x:.1f}, {pixel_y:.1f}), depth={depth_z:.3f}m")
                    print(f"        raw_robot=({raw_robot_x:.2f}, {raw_robot_y:.2f})")
                    print(f"        offset=({offset['x']:.1f}, {offset['y']:.1f})")
                    print(f"        final_robot=({final_robot_x:.2f}, {final_robot_y:.2f})")
            else:
                # Kh√¥ng c√≥ region offset, d√πng raw robot coordinates
                final_robot_x, final_robot_y = raw_robot_x, raw_robot_y
                if self.debug:
                    print(f"      Using position + robot_transform (no region offset):")
                    print(f"        pixel=({pixel_x:.1f}, {pixel_y:.1f}) ‚Üí robot=({final_robot_x:.2f}, {final_robot_y:.2f})")
                
            return final_robot_x, final_robot_y
        
        # ‚≠ê STRATEGY 2: Fallback to pixel center coordinates + region offsets ‚≠ê
        else:
            center_pixel = region_data.get('center', [0, 0])
            pixel_x, pixel_y = center_pixel[0], center_pixel[1]
            
            # Transform pixel coordinates to robot coordinates
            raw_robot_x, raw_robot_y = self.robot_transformer.camera_to_robot(pixel_x, pixel_y)
            
            # ‚≠ê X√ÅC ƒê·ªäNH REGION V√Ä √ÅP D·ª§NG OFFSET ‚≠ê
            region_name = self._determine_region_for_coordinates((pixel_x, pixel_y), region_data)
            if region_name and region_name in self.region_manager.regions:
                offset = self.region_manager.regions[region_name]['offset']
                final_robot_x = raw_robot_x + offset['x']
                final_robot_y = raw_robot_y + offset['y']
                
                if self.debug:
                    print(f"      Fallback center + robot_transform + {region_name} offset:")
                    print(f"        pixel=({pixel_x:.1f}, {pixel_y:.1f})")
                    print(f"        raw_robot=({raw_robot_x:.2f}, {raw_robot_y:.2f})")
                    print(f"        offset=({offset['x']:.1f}, {offset['y']:.1f})")
                    print(f"        final_robot=({final_robot_x:.2f}, {final_robot_y:.2f})")
            else:
                # Kh√¥ng c√≥ region offset, d√πng raw robot coordinates
                final_robot_x, final_robot_y = raw_robot_x, raw_robot_y
                if self.debug:
                    print(f"      Fallback center + robot_transform (no region offset):")
                    print(f"        pixel=({pixel_x:.1f}, {pixel_y:.1f}) ‚Üí robot=({final_robot_x:.2f}, {final_robot_y:.2f})")
                
            return final_robot_x, final_robot_y
    
    def _determine_region_for_coordinates(self, pixel_coords: Tuple[float, float], region_data: Dict) -> Optional[str]:
        """
        ‚≠ê X√°c ƒë·ªãnh region name ƒë·ªÉ √°p d·ª•ng offset d·ª±a tr√™n pixel coordinates ‚≠ê
        
        Args:
            pixel_coords: Pixel coordinates (x, y)
            region_data: Region data from depth results
            
        Returns:
            str: Region name ho·∫∑c None
        """
        # C·ªë g·∫Øng s·ª≠ d·ª•ng RegionManager ƒë·ªÉ x√°c ƒë·ªãnh region
        for region_name in self.region_manager.regions.keys():
            if self.region_manager.is_point_in_region(pixel_coords, region_name):
                return region_name
        
        # Fallback: Heuristic d·ª±a tr√™n class v√† position
        region_info = region_data.get('region_info', {})
        object_class = region_info.get('object_class', '')
        pallet_id = region_info.get('pallet_id', 0)
        
        # Load classes ‚Üí loads region
        if object_class in ['load', 'load2', '0.0', '1.0'] or pallet_id == 0:
            return 'loads'
        
        # Pallet classes ‚Üí d·ª±a tr√™n pallet_id
        elif pallet_id == 1:
            return 'pallets1'
        elif pallet_id == 2:
            return 'pallets2'
        
        return None

def demo_single_image_with_plc():
    """
    Demo v·ªõi m·ªôt ·∫£nh ƒë∆°n l·∫ª: chia regions v√† g·ª≠i v√†o PLC
    """
    print("=== DEMO REGION DIVISION + PLC INTEGRATION ===")
    print("Chia pallets th√†nh regions v√† g·ª≠i t·ªça ƒë·ªô v√†o PLC DB26")
    print()
    
    # C·∫•u h√¨nh PLC
    plc_ip = input("Nh·∫≠p IP PLC (m·∫∑c ƒë·ªãnh: 192.168.0.1): ").strip()
    if not plc_ip:
        plc_ip = "192.168.0.1"
    
    # Ch·ªçn layer
    layer_choice = input("Ch·ªçn layer (1 ho·∫∑c 2, m·∫∑c ƒë·ªãnh 1): ").strip()
    try:
        layer = int(layer_choice) if layer_choice else 1
    except ValueError:
        layer = 1
    
    # Ch·ªçn ·∫£nh
    pallets_folder = "images_pallets2"
    if os.path.exists(pallets_folder):
        image_files = [f for f in os.listdir(pallets_folder) if f.endswith(('.jpg', '.jpeg', '.png'))]
        image_files.sort()
        
        if image_files:
            print("\n·∫¢nh c√≥ s·∫µn:")
            for i, img_file in enumerate(image_files, 1):
                print(f"  {i}. {img_file}")
            
            choice = input(f"\nCh·ªçn ·∫£nh (1-{len(image_files)}): ").strip()
            try:
                choice_num = int(choice)
                if 1 <= choice_num <= len(image_files):
                    image_path = os.path.join(pallets_folder, image_files[choice_num - 1])
                else:
                    image_path = os.path.join(pallets_folder, image_files[0])
            except ValueError:
                image_path = os.path.join(pallets_folder, image_files[0])
        else:
            print("Kh√¥ng t√¨m th·∫•y ·∫£nh trong folder!")
            return
    else:
        print(f"Kh√¥ng t√¨m th·∫•y folder {pallets_folder}!")
        return
    
    # ƒê·ªçc ·∫£nh
    frame = cv2.imread(image_path)
    if frame is None:
        print(f"Kh√¥ng th·ªÉ ƒë·ªçc ·∫£nh: {image_path}")
        return
    
    print(f"\nƒêang x·ª≠ l√Ω ·∫£nh: {image_path}")
    print(f"Layer: {layer}")
    
    # Kh·ªüi t·∫°o system
    print(f"\nKh·ªüi t·∫°o system...")
    engine_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
                              "utils", "detection", "best.engine")
    
    yolo_model = YOLOTensorRT(engine_path=engine_path, conf=0.5)
    region_plc = RegionDivisionPLCIntegration(plc_ip=plc_ip, debug=True)
    
    # K·∫øt n·ªëi PLC
    if not region_plc.connect_plc():
        print("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi PLC! Ti·∫øp t·ª•c demo m√† kh√¥ng g·ª≠i d·ªØ li·ªáu...")
    
    try:
        # Th·ª±c hi·ªán YOLO detection
        print(f"\nTh·ª±c hi·ªán YOLO detection...")
        start_time = time.time()
        detections = yolo_model.detect(frame)
        yolo_time = time.time() - start_time
        
        print(f"YOLO time: {yolo_time*1000:.2f} ms")
        print(f"ƒê√£ ph√°t hi·ªán {len(detections.get('bounding_boxes', []))} objects")
        
        if len(detections.get('bounding_boxes', [])) == 0:
            print("Kh√¥ng ph√°t hi·ªán object n√†o!")
            return
        
        # X·ª≠ l√Ω v√† g·ª≠i v√†o PLC
        print(f"\nX·ª≠ l√Ω regions v√† g·ª≠i v√†o PLC...")
        regions_data, send_success = region_plc.process_detection_and_send_to_plc(detections, layer)
        
        # ƒê·ªçc l·∫°i t·ª´ PLC ƒë·ªÉ verify
        if region_plc.plc_connected:
            print(f"\nƒê·ªçc l·∫°i t·ª´ PLC ƒë·ªÉ verify...")
            time.sleep(0.2)  # ƒê·ª£i m·ªôt ch√∫t
            plc_data = region_plc.read_regions_from_plc()
            
            print(f"D·ªØ li·ªáu trong PLC:")
            for region_name, data in plc_data.items():
                print(f"  {region_name}: Px={data['px']:7.2f} (DB26.{data['px_offset']}), "
                      f"Py={data['py']:7.2f} (DB26.{data['py_offset']})")
        
        # T·∫°o visualization
        print(f"\nT·∫°o visualization...")
        vis_image = region_plc.create_visualization(frame, regions_data)
        
        # Hi·ªÉn th·ªã k·∫øt qu·∫£
        cv2.imshow("YOLO Detection", detections["annotated_frame"])
        cv2.imshow("Region Division + PLC", vis_image)
        
        print(f"\nNh·∫•n ph√≠m b·∫•t k·ª≥ ƒë·ªÉ ti·∫øp t·ª•c...")
        cv2.waitKey(0)
        
        # L∆∞u k·∫øt qu·∫£
        save_choice = input("\nB·∫°n c√≥ mu·ªën l∆∞u k·∫øt qu·∫£? (y/n): ").lower()
        if save_choice in ['y', 'yes']:
            base_name = os.path.splitext(os.path.basename(image_path))[0]
            output_path = f"region_plc_{base_name}_layer{layer}.jpg"
            cv2.imwrite(output_path, vis_image)
            print(f"ƒê√£ l∆∞u: {output_path}")
        
        cv2.destroyAllWindows()
        
    finally:
        # Cleanup
        region_plc.disconnect_plc()

if __name__ == "__main__":
    demo_single_image_with_plc() 